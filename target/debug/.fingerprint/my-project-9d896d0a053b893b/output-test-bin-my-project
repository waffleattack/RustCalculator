{"message":"expected value, found enum `Express`","code":{"code":"E0423","explanation":"An identifier was used like a function name or a value was expected and the\nidentifier exists but it belongs to a different namespace.\n\nErroneous code example:\n\n```compile_fail,E0423\nstruct Foo { a: bool };\n\nlet f = Foo();\n// error: expected function, tuple struct or tuple variant, found `Foo`\n// `Foo` is a struct name, but this expression uses it like a function name\n```\n\nPlease verify you didn't misspell the name of what you actually wanted to use\nhere. Example:\n\n```\nfn Foo() -> u32 { 0 }\n\nlet f = Foo(); // ok!\n```\n\nIt is common to forget the trailing `!` on macro invocations, which would also\nyield this error:\n\n```compile_fail,E0423\nprintln(\"\");\n// error: expected function, tuple struct or tuple variant,\n// found macro `println`\n// did you mean `println!(...)`? (notice the trailing `!`)\n```\n\nAnother case where this error is emitted is when a value is expected, but\nsomething else is found:\n\n```compile_fail,E0423\npub mod a {\n    pub const I: i32 = 1;\n}\n\nfn h1() -> i32 {\n    a.I\n    //~^ ERROR expected value, found module `a`\n    // did you mean `a::I`?\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":589,"byte_end":596,"line_start":34,"line_end":34,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the enum is defined here","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":353,"byte_end":411,"line_start":22,"line_end":25,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"enum Express {","highlight_start":1,"highlight_end":15},{"text":"  Number(i32),","highlight_start":1,"highlight_end":15},{"text":"  Express(Box<Expression>)","highlight_start":1,"highlight_end":27},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you might have meant to write a `struct` literal","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":583,"byte_end":583,"line_start":33,"line_end":33,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"  fn eval(exp : Expression)-> Express{","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"{ SomeStruct ","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":624,"byte_end":624,"line_start":35,"line_end":35,"column_start":4,"column_end":4,"is_primary":true,"text":[{"text":"  }","highlight_start":4,"highlight_end":4}],"label":null,"suggested_replacement":"}","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"the following enum variants are available","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":589,"byte_end":596,"line_start":34,"line_end":34,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":"(Express::Express(/* fields */))","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":589,"byte_end":596,"line_start":34,"line_end":34,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":"(Express::Number(/* fields */))","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this tuple variant instead","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":41,"byte_end":41,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone, Copy)]","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::Express::Express;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0423]\u001b[0m\u001b[0m\u001b[1m: expected value, found enum `Express`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:34:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the enum is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:22:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0menum Express {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  Number(i32),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  Express(Box<Expression>)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to write a `struct` literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m  fn eval(exp : Expression)-> Express\u001b[0m\u001b[0m\u001b[38;5;10m{ SomeStruct \u001b[0m\u001b[0m{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m  }\u001b[0m\u001b[0m\u001b[38;5;10m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the following enum variants are available\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m(Express::Express(/* fields */))\u001b[0m\u001b[0m:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m(Express::Number(/* fields */))\u001b[0m\u001b[0m:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this tuple variant instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[38;5;10muse crate::Express::Express;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"expected type, found local variable `exp`","code":{"code":"E0573","explanation":"Something other than a type has been used when one was expected.\n\nErroneous code examples:\n\n```compile_fail,E0573\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon::Born { // error!\n    Dragon::Born\n}\n\nconst HOBBIT: u32 = 2;\nimpl HOBBIT {} // error!\n\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(_: Wizard::Saruman); // error!\n}\n```\n\nIn all these errors, a type was expected. For example, in the first error, if\nwe want to return the `Born` variant from the `Dragon` enum, we must set the\nfunction to return the enum and not its variant:\n\n```\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon { // ok!\n    Dragon::Born\n}\n```\n\nIn the second error, you can't implement something on an item, only on types.\nWe would need to create a new type if we wanted to do something similar:\n\n```\nstruct Hobbit(u32); // we create a new type\n\nconst HOBBIT: Hobbit = Hobbit(2);\nimpl Hobbit {} // ok!\n```\n\nIn the third case, we tried to only expect one variant of the `Wizard` enum,\nwhich is not possible. To make this work, we need to using pattern matching\nover the `Wizard` enum:\n\n```\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(w: Wizard) { // ok!\n        match w {\n            Wizard::Saruman => {\n                // do something\n            }\n            _ => {} // ignore everything else\n        }\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":615,"byte_end":618,"line_start":34,"line_end":34,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":31,"highlight_end":34}],"label":"not a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might have meant to write a `struct` literal","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":583,"byte_end":583,"line_start":33,"line_end":33,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"  fn eval(exp : Expression)-> Express{","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"{ SomeStruct ","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":624,"byte_end":624,"line_start":35,"line_end":35,"column_start":4,"column_end":4,"is_primary":true,"text":[{"text":"  }","highlight_start":4,"highlight_end":4}],"label":null,"suggested_replacement":"}","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"maybe you meant to write a path separator here","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":596,"byte_end":597,"line_start":34,"line_end":34,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":"::","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0573]\u001b[0m\u001b[0m\u001b[1m: expected type, found local variable `exp`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:34:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to write a `struct` literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m  fn eval(exp : Expression)-> Express\u001b[0m\u001b[0m\u001b[38;5;10m{ SomeStruct \u001b[0m\u001b[0m{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m  }\u001b[0m\u001b[0m\u001b[38;5;10m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: maybe you meant to write a path separator here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Express\u001b[0m\u001b[0m\u001b[38;5;10m::\u001b[0m\u001b[0mExpress(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m~~\u001b[0m\n\n"}
{"message":"parenthesized type parameters may only be used with a `Fn` trait","code":{"code":"E0214","explanation":"A generic type was described using parentheses rather than angle brackets.\n\nErroneous code example:\n\n```compile_fail,E0214\nlet v: Vec(&str) = vec![\"foo\"];\n```\n\nThis is not currently supported: `v` should be defined as `Vec<&str>`.\nParentheses are currently only used with generic types when defining parameters\nfor `Fn`-family traits.\n\nThe previous code example fixed:\n\n```\nlet v: Vec<&str> = vec![\"foo\"];\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":597,"byte_end":620,"line_start":34,"line_end":34,"column_start":13,"column_end":36,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":13,"highlight_end":36}],"label":"only `Fn` traits may use parentheses","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use angle brackets instead","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":604,"byte_end":605,"line_start":34,"line_end":34,"column_start":20,"column_end":21,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":20,"highlight_end":21}],"label":null,"suggested_replacement":"<","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":619,"byte_end":620,"line_start":34,"line_end":34,"column_start":35,"column_end":36,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":35,"highlight_end":36}],"label":null,"suggested_replacement":">","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0214]\u001b[0m\u001b[0m\u001b[1m: parenthesized type parameters may only be used with a `Fn` trait\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:34:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9monly `Fn` traits may use parentheses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use angle brackets instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Express:Express\u001b[0m\u001b[0m\u001b[38;5;10m<\u001b[0m\u001b[0mBox::from(exp)\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"parenthesized type parameters may only be used with a `Fn` trait","code":{"code":"E0214","explanation":"A generic type was described using parentheses rather than angle brackets.\n\nErroneous code example:\n\n```compile_fail,E0214\nlet v: Vec(&str) = vec![\"foo\"];\n```\n\nThis is not currently supported: `v` should be defined as `Vec<&str>`.\nParentheses are currently only used with generic types when defining parameters\nfor `Fn`-family traits.\n\nThe previous code example fixed:\n\n```\nlet v: Vec<&str> = vec![\"foo\"];\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":610,"byte_end":619,"line_start":34,"line_end":34,"column_start":26,"column_end":35,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":26,"highlight_end":35}],"label":"only `Fn` traits may use parentheses","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use angle brackets instead","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":614,"byte_end":615,"line_start":34,"line_end":34,"column_start":30,"column_end":31,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":30,"highlight_end":31}],"label":null,"suggested_replacement":"<","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":618,"byte_end":619,"line_start":34,"line_end":34,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"    Express:Express(Box::from(exp))","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":">","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0214]\u001b[0m\u001b[0m\u001b[1m: parenthesized type parameters may only be used with a `Fn` trait\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:34:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Express:Express(Box::from(exp))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9monly `Fn` traits may use parentheses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use angle brackets instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Express:Express(Box::from\u001b[0m\u001b[0m\u001b[38;5;10m<\u001b[0m\u001b[0mexp\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"duplicate definitions with name `eval`:","code":{"code":"E0201","explanation":"Two associated items (like methods, associated types, associated functions,\netc.) were defined with the same identifier.\n\nErroneous code example:\n\n```compile_fail,E0201\nstruct Foo(u8);\n\nimpl Foo {\n    fn bar(&self) -> bool { self.0 > 5 }\n    fn bar() {} // error: duplicate associated function\n}\n\ntrait Baz {\n    type Quux;\n    fn baz(&self) -> bool;\n}\n\nimpl Baz for Foo {\n    type Quux = u32;\n\n    fn baz(&self) -> bool { true }\n\n    // error: duplicate method\n    fn baz(&self) -> bool { self.0 > 5 }\n\n    // error: duplicate associated type\n    type Quux = u32;\n}\n```\n\nNote, however, that items with the same name are allowed for inherent `impl`\nblocks that don't overlap:\n\n```\nstruct Foo<T>(T);\n\nimpl Foo<u8> {\n    fn bar(&self) -> bool { self.0 > 5 }\n}\n\nimpl Foo<bool> {\n    fn bar(&self) -> bool { self.0 }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":429,"byte_end":449,"line_start":27,"line_end":27,"column_start":3,"column_end":23,"is_primary":false,"text":[{"text":"  fn eval(self) -> i32{","highlight_start":3,"highlight_end":23}],"label":"previous definition of `eval` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":548,"byte_end":583,"line_start":33,"line_end":33,"column_start":3,"column_end":38,"is_primary":true,"text":[{"text":"  fn eval(exp : Expression)-> Express{","highlight_start":3,"highlight_end":38}],"label":"duplicate definition","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0201]\u001b[0m\u001b[0m\u001b[1m: duplicate definitions with name `eval`:\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:33:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  fn eval(self) -> i32{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mprevious definition of `eval` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  fn eval(exp : Expression)-> Express{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mduplicate definition\u001b[0m\n\n"}
{"message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0201, E0214, E0423, E0573.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0201, E0214, E0423, E0573.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0201`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0201`.\u001b[0m\n"}
